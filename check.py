#!/usr/bin/env python3

import socket
import argparse
import ipaddress
import threading
from queue import Queue

class colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    RESET = '\033[0m'

def establish_ssh_connection(ip, port, timeout):
    try:
        sock = socket.create_connection((ip, port), timeout=timeout)
        return sock
    except socket.error:
        return None

def fetch_ssh_banner(sock):
    try:
        banner = sock.recv(1024).decode().strip()
        sock.close()
        return banner
    except Exception as e:
        return str(e)

def scan_target(ip, port, timeout, result_queue):
    sock = establish_ssh_connection(ip, port, timeout)
    if not sock:
        result_queue.put((ip, port, 'closed', "Port is closed"))
        return

    banner = fetch_ssh_banner(sock)
    if "SSH-2.0-OpenSSH" not in banner:
        result_queue.put((ip, port, 'failed', f"Failed to get SSH banner: {banner}"))
        return

    vulnerable_versions = [f'SSH-2.0-OpenSSH_8.{i}' for i in range(5, 10)] + [f'SSH-2.0-OpenSSH_9.{i}' for i in range(0, 8)]
    excluded_versions = [
        'SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.10', 'SSH-2.0-OpenSSH_9.3p1 Ubuntu-3ubuntu3.6',
        'SSH-2.0-OpenSSH_9.6p1 Ubuntu-3ubuntu13.3', 'SSH-2.0-OpenSSH_9.3p1 Ubuntu-1ubuntu3.6',
        'SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u3', 'SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u3'
    ]

    if any(version in banner for version in vulnerable_versions) and banner not in excluded_versions:
        result_queue.put((ip, port, 'vulnerable', f"(running {banner})"))
    else:
        result_queue.put((ip, port, 'not_vulnerable', f"(running {banner})"))

def load_ip_list(filename):
    try:
        with open(filename, 'r') as file:
            return [line.strip() for line in file.readlines()]
    except IOError:
        print(f"{colors.RED}‚ùå Error: Could not read file {filename}{colors.RESET}")
        return []

def main():
    parser = argparse.ArgumentParser(description="Check for vulnerable OpenSSH versions on target servers.")
    parser.add_argument("targets", nargs='*', help="IP addresses, domain names, file paths with IP addresses, or CIDR ranges.")
    parser.add_argument("--port", type=int, default=22, help="Port number to check (default: 22).")
    parser.add_argument("-t", "--timeout", type=float, default=1.0, help="Connection timeout in seconds (default: 1 second).")
    parser.add_argument("-l", "--list", help="File containing IP addresses to check.")

    args = parser.parse_args()

    ips = []
    if args.list:
        ips.extend(load_ip_list(args.list))

    for target in args.targets:
        try:
            with open(target, 'r') as file:
                ips.extend([line.strip() for line in file.readlines()])
        except IOError:
            if '/' in target:
                try:
                    network = ipaddress.ip_network(target, strict=False)
                    ips.extend([str(ip) for ip in network.hosts()])
                except ValueError:
                    print(f"{colors.RED}‚ùå Error: Invalid CIDR range {target}{colors.RESET}")
            else:
                ips.append(target.strip())

    result_queue = Queue()
    threads = []

    for ip in ips:
        thread = threading.Thread(target=scan_target, args=(ip, args.port, args.timeout, result_queue))
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    closed_ports = 0
    not_vulnerable = []
    vulnerable = []

    while not result_queue.empty():
        ip, port, status, message = result_queue.get()
        if status == 'closed':
            closed_ports += 1
        elif status == 'vulnerable':
            vulnerable.append((ip, message))
        else:
            not_vulnerable.append((ip, message))

    print(f"\n{colors.YELLOW}üîç Results:{colors.RESET}")
    for ip, msg in not_vulnerable:
        print(f"   [+] {ip} {msg}")

    print(f"\n{colors.GREEN}üîì Vulnerable servers:{colors.RESET}")
    for ip, msg in vulnerable:
        print(f"   [+] {ip} {msg}")

    print(f"\n{colors.RED}üîí Closed ports:{colors.RESET} {closed_ports}")

if __name__ == "__main__":
    main()
